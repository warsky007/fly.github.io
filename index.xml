<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Warsky007</title>
    <link>https://warsky007.github.io/</link>
      <atom:link href="https://warsky007.github.io/index.xml" rel="self" type="application/rss+xml" />
    <description>Warsky007</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>en-us</language><lastBuildDate>Sat, 01 Jun 2030 13:00:00 +0000</lastBuildDate>
    <image>
      <url>https://warsky007.github.io/images/icon_hu0b7a4cb9992c9ac0e91bd28ffd38dd00_9727_512x512_fill_lanczos_center_2.png</url>
      <title>Warsky007</title>
      <link>https://warsky007.github.io/</link>
    </image>
    
    <item>
      <title>Example Talk</title>
      <link>https://warsky007.github.io/talk/example-talk/</link>
      <pubDate>Sat, 01 Jun 2030 13:00:00 +0000</pubDate>
      <guid>https://warsky007.github.io/talk/example-talk/</guid>
      <description>&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    Click on the &lt;strong&gt;Slides&lt;/strong&gt; button above to view the built-in slides feature.
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Slides can be added in a few ways:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Create&lt;/strong&gt; slides using Wowchemy&amp;rsquo;s &lt;a href=&#34;https://wowchemy.com/docs/managing-content/#create-slides&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;em&gt;Slides&lt;/em&gt;&lt;/a&gt; feature and link using &lt;code&gt;slides&lt;/code&gt; parameter in the front matter of the talk file&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Upload&lt;/strong&gt; an existing slide deck to &lt;code&gt;static/&lt;/code&gt; and link using &lt;code&gt;url_slides&lt;/code&gt; parameter in the front matter of the talk file&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Embed&lt;/strong&gt; your slides (e.g. Google Slides) or presentation video on this page using &lt;a href=&#34;https://wowchemy.com/docs/writing-markdown-latex/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;shortcodes&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Further event details, including &lt;a href=&#34;https://wowchemy.com/docs/writing-markdown-latex/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;page elements&lt;/a&gt; such as image galleries, can be added to the body of this page.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Kerberos协议详解</title>
      <link>https://warsky007.github.io/post/kerberos-protocol/</link>
      <pubDate>Thu, 28 Jan 2021 00:00:00 +0000</pubDate>
      <guid>https://warsky007.github.io/post/kerberos-protocol/</guid>
      <description>&lt;h1 id=&#34;介绍&#34;&gt;介绍&lt;/h1&gt;
&lt;p&gt;最近工作中经常用到Kerberos认证，虽然一些软件已经实现了Kerberos认证，配置一下就能使用，但是我一直不是很清楚它的具体流程，下面通过分析它的协议(Kerberos V5)进一步加深对Kerberos认证的了解。&lt;/p&gt;
&lt;h1 id=&#34;角色&#34;&gt;角色&lt;/h1&gt;
&lt;p&gt;Kerberos是一种第三方认证协议，通过使用对称加密技术为客户端/服务器应用程序提供强身份验证。在希腊神话中Kerberos是守护地狱之门的一条三头神犬，而这三个头分别代表着协议的三个角色，如下图所示它们分别是：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;kdc.png&#34; alt=&#34;kdc&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;访问服务的Client&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;提供服务的Server&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;KDC&lt;/strong&gt;，密钥分发中心，该中心里又包含以下两个服务：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;AS&lt;/strong&gt;，身份验证服务&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TGS&lt;/strong&gt;，票据授权服务&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;流程&#34;&gt;流程&lt;/h1&gt;
&lt;p&gt;Kerberos认证主要通过三个子协议来完成，它们分别为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Authentication Service Exchange&lt;/strong&gt;，身份认证服务交换，是Client与AS之间交互，包含&lt;strong&gt;KRB_AS_REQ&lt;/strong&gt;和&lt;strong&gt;KRB_AS_REP&lt;/strong&gt;两个包。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Ticket-Granting Service (TGS) Exchange&lt;/strong&gt;，票据授权服务交换，是Client与TGS之间交互，包含&lt;strong&gt;KRB_TGS_REQ&lt;/strong&gt;和&lt;strong&gt;KRB_TGS_REP&lt;/strong&gt;两个包。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Client/Server Authentication Exchange&lt;/strong&gt;，客户端/服务认证交换，是Client与Server之间交互，包含&lt;strong&gt;KRB_AP_REQ&lt;/strong&gt;和&lt;strong&gt;KRB_AP_REP&lt;/strong&gt;两个包。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;具体流程如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;exchange.png&#34; alt=&#34;exchange&#34;&gt;&lt;/p&gt;
&lt;p&gt;下面以用户&lt;strong&gt;pixis&lt;/strong&gt;去访问&lt;strong&gt;CIFS&lt;/strong&gt;服务为例来详细讲解一下这3个交换的过程。&lt;/p&gt;
&lt;h2 id=&#34;身份认证服务交换&#34;&gt;身份认证服务交换&lt;/h2&gt;
&lt;p&gt;首先当用户在Client输入用户名和密码时，Client将用户密码的hash值作为加密密钥，对时间戳进行加密，同时附上明文的用户名发送给AS，KRB_AS_REQ包的格式如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;KRB_AS_REQ.png&#34; alt=&#34;KRB_AS_REQ&#34;&gt;&lt;/p&gt;
&lt;p&gt;AS收到KRB_AS_REQ后会通过用户名查找该用户对应密码的hash值，然后去解时间戳，还要对时间戳的有效性进行验证，时间戳不能和AS的时间相差太大，否则就说明两边时间不同步或者是一个重放的请求，AS会直接拒绝该请求，Kerberos认证强依赖于时钟同步，接下来还会看到它的用处。通过这一步AS就完成了对Client的验证以及时钟同步的验证。&lt;/p&gt;
&lt;p&gt;AS会创建一个连接Client和TGS的会话key(Client/TGS Session Key，绿色的钥匙)以及TGT(Ticket Granting Ticket)，TGT中包含用户信息，时间戳，超时时间以及Client/TGS Session Key。AS将TGT用TGS密码的hash值加密(红锁)，将Client/TGS Session Key用该用户(pixis)密码的hash值加密(蓝锁)。然后AS将这两部分放到KRB_AS_REP中返回给Client。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;KRB_AS_REP.png&#34; alt=&#34;KRB_AS_REP&#34;&gt;&lt;/p&gt;
&lt;p&gt;Client收到AS的响应消息以后，利用自身用户(pixis)密码的hash值对KRB_AS_REP中的上半部分进行解密，这样可以获取到Client/TGS Session Key，Client/TGS Session Key是票据授权服务交换阶段需要用到的密钥，票据授权服务交换不再使用用户(pixis)密码的hash值作为密钥。但由于TGT是使用TGS密码的hash值加密的，所以Client无法对其解密。那么这里就有个疑问了，既然Client无法处理TGT，那AS为什么要把它发给Client呢？它到底是干什么用的呢？这个问题接下来再回答。&lt;/p&gt;
&lt;h2 id=&#34;票据授权服务交换&#34;&gt;票据授权服务交换&lt;/h2&gt;
&lt;p&gt;Client使用Client/TGS Session Key对用户信息以及当前的时间戳进行加密生成Authenticator，然后再附上AS发送过来的TGT以及自己要申请访问的服务信息CIFS，生成KRB_TGS_REQ后发送给TGS。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;KRB_TGS_REQ.png&#34; alt=&#34;KRB_TGS_REQ&#34;&gt;&lt;/p&gt;
&lt;p&gt;TGS收到Client发送来的KRB_TGS_REQ后，其逻辑如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;check_process.png&#34; alt=&#34;check_process&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;TGS使用自己的密码对TGT进行解密，然后拿到TGT中的Client/TGS Session Key。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;TGS使用Client/TGS Session Key解开Authenticator，拿到里面的用户名以及时间戳。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;TGS根据前两步解析的信息对Client进行认证并授权。实际上TGS这一步要做甚多事情，下面我简单的列一些：&lt;/p&gt;
&lt;p&gt;比较TGT中的用户名和Authenticator中的用户名是否一致&lt;/p&gt;
&lt;p&gt;比较Authenticator中的时间戳和TGS系统时间的差值是否在一定范围内&lt;/p&gt;
&lt;p&gt;TGS缓存最近一段时间内用户的认证时间，TGS要求Authenticator中的时间戳要晚于该用户最近一次认证的时间&lt;/p&gt;
&lt;p&gt;比较包的源IP和TGT中的IP是否一致&lt;/p&gt;
&lt;p&gt;验证pixis用户是否有访问CIFS的权限&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;通过上面TGS的处理逻辑可以看出，TGT实际上是给TGS用的，TGS需要对它进行解密并获取Client/TGS Session Key以及Client信息。有了Client/TGS Session Key，TGS才能用它解开KRB_TGS_REQ中的Authenticator信息，并对Client进行验证。也就是说在第一阶段AS认证完Client后本来应该把KRB_AS_REP拆成两部分，一部分Client/TGS Session Key发给Client，另一部分TGT发给TGS，但是AS没有这样做，而是把这两部分都发给了Client，这是为什么呢？首先网络传输有延时，AS没法保证TGS在收到KRB_TGS_REQ之前必须收到TGT，AS和TGS是两个独立的服务，除了AS里面存有TGS的密码外它们之间没有太多的联系，既然这样还不如让Client代为发送TGT。其次如果AS直接发送TGT给TGS，TGS势必要缓存TGT里面的信息，这就增加的TGS的复杂度。&lt;/p&gt;
&lt;p&gt;验证通过后，TGS会创建一个连接Client和Server之间的会话key(Client/Server Session Key，紫色的钥匙)以及ST(Service Ticket)，ST中包含用户信息，Service信息以及Client/Server Session Key。TGS将ST用Server密码的hash值加密(黄锁)，将Client/Server Session Key用Client/TGS Session Key加密(绿锁)。然后TGS将这两部分放到KRB_TGS_REP中返回给Client。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;KRB_TGS_REP.png&#34; alt=&#34;KRB_TGS_REP&#34; style=&#34;zoom:50%;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;有没有觉得KRB_TGS_REP和身份认证服务交换阶段的KRB_AS_REP很像，只不过Client/TGS Session Key变成了Client/Server Session Key，TGT变成了ST。&lt;/p&gt;
&lt;h2 id=&#34;客户端服务认证交换&#34;&gt;客户端/服务认证交换&lt;/h2&gt;
&lt;p&gt;接下来的逻辑就跟票据授权服务交换阶段很像了。Client使用Client/Server Session Key对用户信息以及当前的时间戳进行加密生成Authenticator，然后再附上TGS发送过来的ST，生成KRB_AP_REQ后发送给Server。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;KRB_AP_REQ.png&#34; alt=&#34;KRB_AP_REQ&#34; style=&#34;zoom:50%;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Server端的处理逻辑也跟票据授权服务交换阶段的TGS服务很像，这里就不赘述了，现在我们看看Server端返回什么。为了防止Server是个假的Server，Client要求Server将Authenticator字段中的Timestamp用Client/Server Session Key加密后发回来，通过上图我们知道，Server要想得到Client/Server Session Key，必须要有密码来解开ST才行，只有真的Server才有密码解开ST，而假的Server是拿不到Client/Server Session Key的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;KRB_AP_REP.png&#34; alt=&#34;KRB_AP_REP&#34; style=&#34;zoom:50%;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Client收到KRB_AP_REP后用Client/Server Session Key对其解密，得到Timestamp后然后跟之前发送的Timestamp对比，信息一致就说明对端是真的Server，这样就完成了Client和Server间的双向认证。&lt;/p&gt;
&lt;h1 id=&#34;tgs服务&#34;&gt;TGS服务&lt;/h1&gt;
&lt;p&gt;看完上面的流程后总感觉有些麻烦，2，3和4，5干的事情很像，有点多余。Client访问完AS后直接得到Client/Server Session Key和TGS，然后Client拿着这些直接访问Server不香吗？就像下图这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;simple_process.png&#34; alt=&#34;simple_process&#34;&gt;&lt;/p&gt;
&lt;p&gt;总觉得Client/TGS Session Key和TGT是多余的，后来才明白Kerberos是要实现单点登录的，按上图的方案，Client访问每个服务都要输入一次用户名密码，当Kerberos管理的服务很多时这是无法接收的。另外Client/TGS Session Key是有过期时间的，即使被破解了也会因为过期而不带来太大的风险，如果一直使用用户的密码就不好说了，因为用户密码的更新时间是不确定的，如果经常用它来加密一些数据放在公网上传输，时间久了是不安全的。从上面的流程我们可以看出，Kerberos认证依赖于只有用户自己和AS知道用户的密码，如果有第三方知道了用户的密码整个认证就失效了。所以最好是一次登录，接下来的交互都使用Client/TGS Session Key和TGT。就像下图所示的一样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;actual_process.png&#34; alt=&#34;actual_process&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;总结&#34;&gt;总结&lt;/h1&gt;
&lt;p&gt;以上只是简要的概述了整个协议的流程，但实际的逻辑以及交互包的格式远比上面介绍的复杂，有兴趣的朋友可以去研究一下它的说明书rfc1510。&lt;/p&gt;
&lt;h1 id=&#34;参考&#34;&gt;参考&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://tools.ietf.org/html/rfc1510&#34;&gt;https://tools.ietf.org/html/rfc1510&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/wannuoge4766/article/details/106303372/&#34;&gt;https://blog.csdn.net/wannuoge4766/article/details/106303372/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://en.hackndo.com/kerberos/&#34;&gt;https://en.hackndo.com/kerberos/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://www.nosqlnotes.com/technotes/kerberos-protocol/&#34;&gt;http://www.nosqlnotes.com/technotes/kerberos-protocol/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>golang带宽限制</title>
      <link>https://warsky007.github.io/post/bandwidth-limiter/</link>
      <pubDate>Tue, 26 Jan 2021 00:00:00 +0000</pubDate>
      <guid>https://warsky007.github.io/post/bandwidth-limiter/</guid>
      <description>&lt;h1 id=&#34;介绍&#34;&gt;介绍&lt;/h1&gt;
&lt;p&gt;很多客户使用多中心部署的时候副中心和主中心之间都是走专线的，专线的带宽是有限的，很多服务共享此带宽。为了防止一个服务把带宽占尽而导致其它服务无法工作，这就要求服务有带宽限制的功能。本文基于golang的time/rate模块实现了一个线程安全的带宽限制器，该带宽限制器本质上还是基于Token Bucket(令牌桶)实现的。下面提供源码以供大家参考。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;import (
	&amp;quot;context&amp;quot;
	&amp;quot;fmt&amp;quot;
	&amp;quot;golang.org/x/time/rate&amp;quot;
	&amp;quot;sync/atomic&amp;quot;
	&amp;quot;unsafe&amp;quot;
)

type BandwidthLimiter struct {
	limiter   *rate.Limiter
	ctx       context.Context
	cancel    context.CancelFunc
	bandwidth int
}

func NewBandwidthLimiter(bandwidth int) (*BandwidthLimiter, error) {
	if bandwidth &amp;lt; 0 {
		return nil, fmt.Errorf(&amp;quot;invalid argument bandwidth %d&amp;quot;, bandwidth)
	}

	limiter := rate.NewLimiter(rate.Limit(bandwidth), bandwidth)
	ctx, cancel := context.WithCancel(context.Background())
	return &amp;amp;BandwidthLimiter{
		limiter:   limiter,
		ctx:       ctx,
		cancel:    cancel,
		bandwidth: bandwidth,
	}, nil
}

func (bl *BandwidthLimiter) Wait(num int) error {
	bandwidth := bl.bandwidth
	if bandwidth == 0 || num &amp;lt;= 0 {
		return nil
	}

	if num &amp;lt;= bandwidth {
		return bl.limiter.WaitN(bl.ctx, num)
	} else {
		for i := 0; i &amp;lt; num/bandwidth; i++ {
			bl.limiter.WaitN(bl.ctx, bandwidth)
		}
		return bl.limiter.WaitN(bl.ctx, num%bandwidth)
	}
}

func (bl *BandwidthLimiter) UpdateBandwidth(bandwidth int) error {
	if bandwidth &amp;lt; 0 {
		return fmt.Errorf(&amp;quot;invalid argument bandwidth %d&amp;quot;, bandwidth)
	}

	bl.limiter.SetLimit(rate.Limit(bandwidth))
	bl.limiter.SetBurst(bandwidth)
	atomic.StoreInt32((*int32)(unsafe.Pointer(&amp;amp;bl.bandwidth)), int32(bandwidth))
	return nil
}

func (bl *BandwidthLimiter) Stop() {
	bl.cancel()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;使用&#34;&gt;使用&lt;/h1&gt;
&lt;p&gt;使用方法如下，在Write发送数据之前或者Read接收数据之后，调用BandwidthLimiter的Wait方法即可实现限速。虽然此方案在1s内可能会有burst，但是1s内的平均速率不会超过限额，这种精度基本上够用了。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func witeWithLimiter(con net.Conn, limiter *BandwidthLimiter, data []byte) (int, error) {
	if limiter != nil {
		if err := limiter.Wait(len(data)); err != nil {
			return 0, err
		}
	}

	return con.Write(data)
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>ClickHouse存储结构及索引详解</title>
      <link>https://warsky007.github.io/post/clickhouse-storage-index/</link>
      <pubDate>Tue, 12 Jan 2021 00:00:00 +0000</pubDate>
      <guid>https://warsky007.github.io/post/clickhouse-storage-index/</guid>
      <description>&lt;h1 id=&#34;环境介绍&#34;&gt;环境介绍&lt;/h1&gt;
&lt;p&gt;本文基于ClickHouse 20.8.5.45版本编写，操作系统使用的是CentOS 7.5，主要介绍MergeTree表引擎的存储结构以及索引过程。&lt;/p&gt;
&lt;h1 id=&#34;创建表&#34;&gt;创建表&lt;/h1&gt;
&lt;h3 id=&#34;创建语句&#34;&gt;创建语句&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;CREATE TABLE test_merge_tree
(
    `Id` UInt64,
    `Birthday` Date,
    `Name` String
)
ENGINE = MergeTree()
PARTITION BY toYYYYMM(Birthday)
ORDER BY (Id, Name)
SETTINGS index_granularity = 2
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;语句介绍&#34;&gt;语句介绍&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;ENGINE&lt;/strong&gt;，表引擎。ClickHouse支持很多种表引擎，本文主要讲解MergeTree，所以选用合并树。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;PARTITION BY&lt;/strong&gt;，分区键。用于指定数据以何种方式分区，合理使用分区可以有效减少查询时文件的扫描范围。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ORDER BY&lt;/strong&gt;，排序键。用于指定数据以何种方式排序，默认情况下排序键和主键相同。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SETTINGS&lt;/strong&gt;，配置。创建MergeTree Table时使用的配置，可选的配置有很多，这里只介绍index_granularity。index_granularity表示索引粒度，代表每隔多少行数据生成一条索引，默认值是8192。默认值需要的数据量很大，不方便本文展示数据文件，所以这里我把它调小了。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;文件结构&#34;&gt;文件结构&lt;/h1&gt;
&lt;p&gt;刚刚创建的表只在数据目录下生成了一个名为&lt;strong&gt;test_merge_tree&lt;/strong&gt;文件夹(具体路径为data/default/test_merge_tree)，并没有任何数据，接下来往该表里面插入一条数据，看看会生成哪些文件。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;INSERT INTO test_merge_tree VALUES(1, &#39;2000-02-01&#39;, &#39;Fly li&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在test_merge_tree目录下使用tree命令可以看到刚刚的那条命令生成了一个名为&lt;strong&gt;200002_1_1_0&lt;/strong&gt;的文件夹。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;├── 200002_1_1_0
│   ├── Birthday.bin
│   ├── Birthday.mrk2
│   ├── checksums.txt
│   ├── columns.txt
│   ├── count.txt
│   ├── Id.bin
│   ├── Id.mrk2
│   ├── minmax_Birthday.idx
│   ├── Name.bin
│   ├── Name.mrk2
│   ├── partition.dat
│   └── primary.idx
├── detached
└── format_version.txt
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;分区目录命名规则&#34;&gt;分区目录命名规则&lt;/h3&gt;
&lt;p&gt;在介绍这些文件之前先介绍一下200002_1_1_0这个目录的命名规则&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;PartitionId_MinBlockNum_MaxBlockNum_Level
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;PartitionId&lt;/strong&gt;，分区Id。其值是由创建表时所指定的分区键决定的，由于我们创建表时使用的分区键为toYYYYMM(Birthday)，即生日的年月，而插入的Birthday为2000-02-01，所以其值为200002。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;MinBlockNum、MaxBlockNum&lt;/strong&gt;，最小最大数据块编号。其值在单张表内从1开始累加，每当新创建一个分区目录其值就会加1，且新创建的分区目录MinBlockNum和MaxBlockNum相等，只有当分区目录发生合并时其值才会不等。由于这是该表第一次插入数据，所以MinBlockNum和MaxBlockNum都为1。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Level&lt;/strong&gt;，分区被合并的次数。level和MinBlockNum以及MaxBlockNum不同，它不是单张表内累加的，而是单张表中的单个分区内累加的。每当新创建一个分区目录其值均为0，只有当分区目录发生合并时其值才会大于0。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当分区发生合并时，新的分区目录名称命名规则将会在接下来介绍，这里不做详述。&lt;/p&gt;
&lt;h3 id=&#34;文件介绍&#34;&gt;文件介绍&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;文件名&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;primary.idx&lt;/td&gt;
&lt;td&gt;索引文件&lt;/td&gt;
&lt;td&gt;用于存放稀疏索引&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;[Column].mrk2&lt;/td&gt;
&lt;td&gt;标记文件&lt;/td&gt;
&lt;td&gt;保存了bin文件中数据的偏移信息，用于建立primary.idx和[Column].bin文件之间的映射&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;[Column].bin&lt;/td&gt;
&lt;td&gt;数据文件&lt;/td&gt;
&lt;td&gt;存储数据，默认使用lz4压缩存储&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;partition.dat&lt;/td&gt;
&lt;td&gt;分区文件&lt;/td&gt;
&lt;td&gt;用于保存分区表达式生成的值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;minmax_[Column].idx&lt;/td&gt;
&lt;td&gt;minmax索引&lt;/td&gt;
&lt;td&gt;用于记录当前分区下分区字段的最小最大值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;columns.txt&lt;/td&gt;
&lt;td&gt;列信息文件&lt;/td&gt;
&lt;td&gt;用于保存表的列字段信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;count.txt&lt;/td&gt;
&lt;td&gt;计数文件&lt;/td&gt;
&lt;td&gt;用于记录当前分区目录下数据的总行数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;checksums.txt&lt;/td&gt;
&lt;td&gt;校验文件&lt;/td&gt;
&lt;td&gt;存放以上各个文件的size以及哈希值，用于快速校验文件的完整性&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;存储结构&#34;&gt;存储结构&lt;/h1&gt;
&lt;h3 id=&#34;修改min_compress_block_size&#34;&gt;修改min_compress_block_size&lt;/h3&gt;
&lt;p&gt;在介绍这部分之前，需要先将min_compress_block_size配置改小，以方便分析mrk2和bin文件，其默认值为65535。&lt;/p&gt;
&lt;p&gt;修改方法为在&lt;strong&gt;users.xml&lt;/strong&gt;文件的&lt;strong&gt;profiles&lt;/strong&gt;里面增加以下配置&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;min_compress_block_size&amp;gt;24&amp;lt;/min_compress_block_size&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;修改完后重启clickhouse-server服务，然后再用以下命令查看是否修改成功&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT 
    name,
    value,
    changed,
    type
FROM system.settings
WHERE name = &#39;min_compress_block_size&#39;

┌─name────────────────────┬─value─┬─changed─┬─type───┐
│ min_compress_block_size │ 24    │       1 │ UInt64 │
└─────────────────────────┴───────┴─────────┴────────┘
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;插入数据&#34;&gt;插入数据&lt;/h3&gt;
&lt;p&gt;刚刚已经插入了一条数据，但是那一条数据不具有代表性，所以这次决定多插入几条数据再来分析。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;INSERT INTO test_merge_tree VALUES(3, &#39;2000-02-03&#39;, &#39;Lisa&#39;),(4, &#39;2000-02-03&#39;, &#39;Lilei&#39;),(6, &#39;2000-02-08&#39;, &#39;Meimei&#39;),(12, &#39;2000-02-03&#39;, &#39;paker&#39;),(31, &#39;2000-02-07&#39;, &#39;vincent&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面这条命令产生了个新的分区目录&lt;strong&gt;200002_2_2_0&lt;/strong&gt;，此目录下的文件前面已经讲过，现在重点分析以下几个文件的存储格式&lt;/p&gt;
&lt;h4 id=&#34;primaryidx&#34;&gt;primary.idx&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;primary.png&#34; alt=&#34;primary&#34;&gt;
MergeTree表会按照主键字段生成primary.idx，用于加快表查询。前面创建表时使用的是(Id, Name)两个字段作为主键，所以每隔index_granularity行数据就会取(Id, Name)的值作为索引值，由于index_granularity被设置为2，所以每隔两行数据就会生成一个索引。也就是说会使用(3,&amp;lsquo;Lisa&amp;rsquo;), (6,&amp;lsquo;Meimei&amp;rsquo;), (31,&amp;lsquo;vincent&amp;rsquo;)作为索引值。&lt;/p&gt;
&lt;p&gt;这里我只介绍第一个索引(3,&amp;lsquo;Lisa&amp;rsquo;)的存储格式，剩下的可以自己去梳理。Id是UInt64类型的，所以使用8字节来存储。从上图可以看出前8个字节为0x03，以小端模式来存储，接下来我们可以看到其它文件都是以小端模式来存储。Name是String类型，属于变长字段，所以会先使用1个字节来描述String的长度，由于Lisa的长度是4，所以第9个字节为0x04，再接下来就是Lisa的ASCII码。&lt;/p&gt;
&lt;h4 id=&#34;idmrk2&#34;&gt;Id.mrk2&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;mrk2.png&#34; alt=&#34;mrk2&#34;&gt;
mrk2文件格式比较固定，primary.idx文件中的每个索引在此文件中都有一个对应的Mark，Mark的格式如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;mark.png&#34; alt=&#34;mark&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Offset in compressed file，8 Bytes，代表该标记指向的压缩数据块在bin文件中的偏移量。&lt;/li&gt;
&lt;li&gt;Offset in decompressed block，8 Bytes，代表该标记指向的数据在解压数据块中的偏移量。&lt;/li&gt;
&lt;li&gt;Rows count，8 Bytes，行数，通常情况下其等于index_granularity。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;通过primary.idx中的索引寻找mrk2文件中对应的Mark非常简单，如果要寻找第n(从0开始)个index，则对应的Mark在mrk2文件中的偏移为n*24，从这个偏移处开始读取24 Bytes即可得到相应的Mark。&lt;/p&gt;
&lt;h4 id=&#34;idbin&#34;&gt;Id.bin&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;bin.png&#34; alt=&#34;bin&#34;&gt;
bin文件由若干个Block组成，由上图可知Id.bin文件中包含两个Block。每个Block主要由头部的Checksum以及若干个Granule组成，Block的格式如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;block.png&#34; alt=&#34;block&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Checksum&lt;/strong&gt;，16 Bytes，用于对后面的数据进行校验。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Compression algorithm&lt;/strong&gt;，1 Byte，默认是LZ4，编号为0x82。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Compressed size&lt;/strong&gt;，4 Bytes，其值等于Compression algorithm + Compressed size + Decompressed size + Compressed data的长度&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Decompressed size&lt;/strong&gt;，4 Bytes，数据解压缩后的长度。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Compressed data&lt;/strong&gt;，压缩数据，长度为Compressed size - 9。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;每个Block都会包含若干个Granule，具体有多少个Granule是由参数min_compress_block_size控制，每次Block中写完一个Granule的数据时，它会检查当前Block Size是否大于等于min_compress_block_size，如果满足则会把当前Block进行压缩然后写到磁盘中，不满足会继续等待下一个Granule。结合上面的INSERT语句，当插入第一个Granule(3, 4)时，数据的的size为16，由于16 &amp;lt; 24所以会等第二个Granule，当插入第二个Granule(6, 12)后数据的size为32，由于32 &amp;gt; 24所以会把(3, 4, 6, 12)压缩放到第一个Block里面。最后面的那个31由于是最后一条数据，就放到第二个Block里面。&lt;/p&gt;
&lt;h4 id=&#34;partitiondat&#34;&gt;partition.dat&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;partition.png&#34; alt=&#34;partition&#34;&gt;
partition.dat文件里面存放的是分区表达式的值，该分区表达式生成的值为200002，UInt32类型，转换成16进制就是0x00030d42。&lt;/p&gt;
&lt;h4 id=&#34;minmax_birthdayidx&#34;&gt;minmax_Birthday.idx&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;minmax.png&#34; alt=&#34;minmax&#34;&gt;
minmax文件里面存放的是该分区里分区字段的最小最大值。分区字段Birthday的类型为Date，其底层由UInt16实现，存的是从1970年1月1号到现在所经过的天数。通过上面的INSERT语句我们可以知道Birthday的最小值为2000-02-03，最大值为2000-02-08。这两个时间转换成天数分别为10990和10995，再转换成16进制就是0x2aee和0x2af3。&lt;/p&gt;
&lt;h1 id=&#34;分区合并&#34;&gt;分区合并&lt;/h1&gt;
&lt;p&gt;属于同一个分区的不同目录，ClickHouse会在分区目录创建后的一段时间自动进行合并，合并之后会生成一个全新的目录，以前老的分区目录不会立马删除，而是在合并后过一段时间再删除。新的分区目录名称遵循以下规则：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;PartitionId，分区Id不变。&lt;/li&gt;
&lt;li&gt;MinBlockNum，取该分区中最小的MinBlockNum。&lt;/li&gt;
&lt;li&gt;MaxBlockNum，取该分区中最大的MaxBlockNum。&lt;/li&gt;
&lt;li&gt;Level，取该分区中最大的Level值加1。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;所以上面的两个分区目录200002_1_1_0和200002_2_2_0在过一段时间后最终会变成一个新的分区目录200002_1_2_1。由此可见如果你频繁插入数据会产生很多分区目录，在合并的时候会占用很多资源。所以最好一次插入很多条数据，尽量降低插入的频率。&lt;/p&gt;
&lt;h1 id=&#34;索引过程&#34;&gt;索引过程&lt;/h1&gt;
&lt;p&gt;通过上面的介绍相信大家已经对ClickHouse的索引结构有所了解，接下来用一张图简要描述Id字段的索引过程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;indexing.png&#34; alt=&#34;indexing&#34;&gt;
其它列的索引过程类似，这里就不一一赘述了，有兴趣的朋友可以自己去研究。&lt;/p&gt;
&lt;h1 id=&#34;总结&#34;&gt;总结&lt;/h1&gt;
&lt;p&gt;本文通过一个简单的例子来分析ClickHouse的存储结构，整个逻辑力求简洁明了，希望通过本文能够让喜欢ClickHouse的朋友对它的索引有个清晰的认识。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>嗖...</title>
      <link>https://warsky007.github.io/post/getting-started/</link>
      <pubDate>Fri, 08 Jan 2021 00:00:00 +0000</pubDate>
      <guid>https://warsky007.github.io/post/getting-started/</guid>
      <description>&lt;p&gt;2020年已经过去，去年注定是个不平凡的一年，新冠病毒肆虐，很多人因为疫情而举步维艰，也有一些人甚至失去了生命。幸运的是我这个小家庭没有受到太大的影响，家人孩子一切平安。&lt;/p&gt;
&lt;p&gt;平时工作很忙，周末还要回家带娃，我每天就这么忙碌着，浑浑噩噩的过着。突然有一天我感觉时间过的好快，似乎自己什么也没做一年就这样过去了，而人生又有多少个一年呢？我想我该放慢脚步，用心记录下生活中的美好瞬间，这样等哪一天闲的没事了，看着这些东西也许就不会觉得我在浪费青春了。&lt;/p&gt;
&lt;p&gt;好记性不如烂笔头，希望在接下来的工作当中能够多抽出一些时间来记录工作中遇到的一些问题，解决方案，以及学到的一些知识。&lt;/p&gt;
&lt;p&gt;好的东西就是要拿出来分享，愿与君共勉！！！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Slides</title>
      <link>https://warsky007.github.io/slides/example/</link>
      <pubDate>Tue, 05 Feb 2019 00:00:00 +0000</pubDate>
      <guid>https://warsky007.github.io/slides/example/</guid>
      <description>&lt;h1 id=&#34;create-slides-in-markdown-with-wowchemy&#34;&gt;Create slides in Markdown with Wowchemy&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://wowchemy.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Wowchemy&lt;/a&gt; | &lt;a href=&#34;https://owchemy.com/docs/managing-content/#create-slides&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Documentation&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;features&#34;&gt;Features&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Efficiently write slides in Markdown&lt;/li&gt;
&lt;li&gt;3-in-1: Create, Present, and Publish your slides&lt;/li&gt;
&lt;li&gt;Supports speaker notes&lt;/li&gt;
&lt;li&gt;Mobile friendly slides&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;controls&#34;&gt;Controls&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Next: &lt;code&gt;Right Arrow&lt;/code&gt; or &lt;code&gt;Space&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Previous: &lt;code&gt;Left Arrow&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Start: &lt;code&gt;Home&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Finish: &lt;code&gt;End&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Overview: &lt;code&gt;Esc&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Speaker notes: &lt;code&gt;S&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Fullscreen: &lt;code&gt;F&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Zoom: &lt;code&gt;Alt + Click&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/hakimel/reveal.js#pdf-export&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;PDF Export&lt;/a&gt;: &lt;code&gt;E&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;code-highlighting&#34;&gt;Code Highlighting&lt;/h2&gt;
&lt;p&gt;Inline code: &lt;code&gt;variable&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Code block:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;porridge = &amp;quot;blueberry&amp;quot;
if porridge == &amp;quot;blueberry&amp;quot;:
    print(&amp;quot;Eating...&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;math&#34;&gt;Math&lt;/h2&gt;
&lt;p&gt;In-line math: $x + y = z$&lt;/p&gt;
&lt;p&gt;Block math:&lt;/p&gt;
&lt;p&gt;$$
f\left( x \right) = ;\frac{{2\left( {x + 4} \right)\left( {x - 4} \right)}}{{\left( {x + 4} \right)\left( {x + 1} \right)}}
$$&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;fragments&#34;&gt;Fragments&lt;/h2&gt;
&lt;p&gt;Make content appear incrementally&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{{% fragment %}} One {{% /fragment %}}
{{% fragment %}} **Two** {{% /fragment %}}
{{% fragment %}} Three {{% /fragment %}}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Press &lt;code&gt;Space&lt;/code&gt; to play!&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;fragment &#34; &gt;
One
&lt;/span&gt;
&lt;span class=&#34;fragment &#34; &gt;
&lt;strong&gt;Two&lt;/strong&gt;
&lt;/span&gt;
&lt;span class=&#34;fragment &#34; &gt;
Three
&lt;/span&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;A fragment can accept two optional parameters:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;class&lt;/code&gt;: use a custom style (requires definition in custom CSS)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;weight&lt;/code&gt;: sets the order in which a fragment appears&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;speaker-notes&#34;&gt;Speaker Notes&lt;/h2&gt;
&lt;p&gt;Add speaker notes to your presentation&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;{{% speaker_note %}}
- Only the speaker can read these notes
- Press `S` key to view
{{% /speaker_note %}}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Press the &lt;code&gt;S&lt;/code&gt; key to view the speaker notes!&lt;/p&gt;
&lt;aside class=&#34;notes&#34;&gt;
  &lt;ul&gt;
&lt;li&gt;Only the speaker can read these notes&lt;/li&gt;
&lt;li&gt;Press &lt;code&gt;S&lt;/code&gt; key to view&lt;/li&gt;
&lt;/ul&gt;

&lt;/aside&gt;
&lt;hr&gt;
&lt;h2 id=&#34;themes&#34;&gt;Themes&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;black: Black background, white text, blue links (default)&lt;/li&gt;
&lt;li&gt;white: White background, black text, blue links&lt;/li&gt;
&lt;li&gt;league: Gray background, white text, blue links&lt;/li&gt;
&lt;li&gt;beige: Beige background, dark text, brown links&lt;/li&gt;
&lt;li&gt;sky: Blue background, thin dark text, blue links&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;night: Black background, thick white text, orange links&lt;/li&gt;
&lt;li&gt;serif: Cappuccino background, gray text, brown links&lt;/li&gt;
&lt;li&gt;simple: White background, black text, blue links&lt;/li&gt;
&lt;li&gt;solarized: Cream-colored background, dark green text, blue links&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;

&lt;section data-noprocess data-shortcode-slide
  
      
      data-background-image=&#34;/media/boards.jpg&#34;
  &gt;

&lt;h2 id=&#34;custom-slide&#34;&gt;Custom Slide&lt;/h2&gt;
&lt;p&gt;Customize the slide style and background&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;{{&amp;lt; slide background-image=&amp;quot;/media/boards.jpg&amp;quot; &amp;gt;}}
{{&amp;lt; slide background-color=&amp;quot;#0000FF&amp;quot; &amp;gt;}}
{{&amp;lt; slide class=&amp;quot;my-style&amp;quot; &amp;gt;}}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;custom-css-example&#34;&gt;Custom CSS Example&lt;/h2&gt;
&lt;p&gt;Let&amp;rsquo;s make headers navy colored.&lt;/p&gt;
&lt;p&gt;Create &lt;code&gt;assets/css/reveal_custom.css&lt;/code&gt; with:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;.reveal section h1,
.reveal section h2,
.reveal section h3 {
  color: navy;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;questions&#34;&gt;Questions?&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/wowchemy/wowchemy-hugo-modules/discussions&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Ask&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://wowchemy.com/docs/managing-content/#create-slides&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Documentation&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Example Project</title>
      <link>https://warsky007.github.io/project/example/</link>
      <pubDate>Wed, 27 Apr 2016 00:00:00 +0000</pubDate>
      <guid>https://warsky007.github.io/project/example/</guid>
      <description>&lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere tellus ac convallis placerat. Proin tincidunt magna sed ex sollicitudin condimentum. Sed ac faucibus dolor, scelerisque sollicitudin nisi. Cras purus urna, suscipit quis sapien eu, pulvinar tempor diam. Quisque risus orci, mollis id ante sit amet, gravida egestas nisl. Sed ac tempus magna. Proin in dui enim. Donec condimentum, sem id dapibus fringilla, tellus enim condimentum arcu, nec volutpat est felis vel metus. Vestibulum sit amet erat at nulla eleifend gravida.&lt;/p&gt;
&lt;p&gt;Nullam vel molestie justo. Curabitur vitae efficitur leo. In hac habitasse platea dictumst. Sed pulvinar mauris dui, eget varius purus congue ac. Nulla euismod, lorem vel elementum dapibus, nunc justo porta mi, sed tempus est est vel tellus. Nam et enim eleifend, laoreet sem sit amet, elementum sem. Morbi ut leo congue, maximus velit ut, finibus arcu. In et libero cursus, rutrum risus non, molestie leo. Nullam congue quam et volutpat malesuada. Sed risus tortor, pulvinar et dictum nec, sodales non mi. Phasellus lacinia commodo laoreet. Nam mollis, erat in feugiat consectetur, purus eros egestas tellus, in auctor urna odio at nibh. Mauris imperdiet nisi ac magna convallis, at rhoncus ligula cursus.&lt;/p&gt;
&lt;p&gt;Cras aliquam rhoncus ipsum, in hendrerit nunc mattis vitae. Duis vitae efficitur metus, ac tempus leo. Cras nec fringilla lacus. Quisque sit amet risus at ipsum pharetra commodo. Sed aliquam mauris at consequat eleifend. Praesent porta, augue sed viverra bibendum, neque ante euismod ante, in vehicula justo lorem ac eros. Suspendisse augue libero, venenatis eget tincidunt ut, malesuada at lorem. Donec vitae bibendum arcu. Aenean maximus nulla non pretium iaculis. Quisque imperdiet, nulla in pulvinar aliquet, velit quam ultrices quam, sit amet fringilla leo sem vel nunc. Mauris in lacinia lacus.&lt;/p&gt;
&lt;p&gt;Suspendisse a tincidunt lacus. Curabitur at urna sagittis, dictum ante sit amet, euismod magna. Sed rutrum massa id tortor commodo, vitae elementum turpis tempus. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aenean purus turpis, venenatis a ullamcorper nec, tincidunt et massa. Integer posuere quam rutrum arcu vehicula imperdiet. Mauris ullamcorper quam vitae purus congue, quis euismod magna eleifend. Vestibulum semper vel augue eget tincidunt. Fusce eget justo sodales, dapibus odio eu, ultrices lorem. Duis condimentum lorem id eros commodo, in facilisis mauris scelerisque. Morbi sed auctor leo. Nullam volutpat a lacus quis pharetra. Nulla congue rutrum magna a ornare.&lt;/p&gt;
&lt;p&gt;Aliquam in turpis accumsan, malesuada nibh ut, hendrerit justo. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Quisque sed erat nec justo posuere suscipit. Donec ut efficitur arcu, in malesuada neque. Nunc dignissim nisl massa, id vulputate nunc pretium nec. Quisque eget urna in risus suscipit ultricies. Pellentesque odio odio, tincidunt in eleifend sed, posuere a diam. Nam gravida nisl convallis semper elementum. Morbi vitae felis faucibus, vulputate orci placerat, aliquet nisi. Aliquam erat volutpat. Maecenas sagittis pulvinar purus, sed porta quam laoreet at.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>An example conference paper</title>
      <link>https://warsky007.github.io/publication/example/</link>
      <pubDate>Mon, 01 Jul 2013 00:00:00 +0000</pubDate>
      <guid>https://warsky007.github.io/publication/example/</guid>
      <description>&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    Click the &lt;em&gt;Cite&lt;/em&gt; button above to demo the feature to enable visitors to import publication metadata into their reference management software.
  &lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    Create your slides in Markdown - click the &lt;em&gt;Slides&lt;/em&gt; button to check out the example.
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Supplementary notes can be added here, including &lt;a href=&#34;https://wowchemy.com/docs/writing-markdown-latex/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;code, math, and images&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
